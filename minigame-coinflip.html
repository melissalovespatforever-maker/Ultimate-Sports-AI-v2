<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultimate Chess</title>
<style>
  body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; background: #f0f0f0; }
  #chessboard { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px); margin-top: 20px; }
  .square { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; font-size: 36px; cursor: pointer; user-select: none; }
  .white { background: #f0d9b5; }
  .black { background: #b58863; }
  .highlight { background: yellow !important; }
  button { margin-top: 20px; padding: 10px 20px; font-size: 16px; }
</style>
</head>
<body>

<h1>Ultimate Chess</h1>
<div id="chessboard"></div>
<button onclick="resetBoard()">Restart Game</button>

<script>
const boardEl = document.getElementById('chessboard');

let board = [];
let selected = null;
let turn = 'w'; // w = white, b = black

const pieces = {
  'wP': '♙', 'wR': '♖', 'wN': '♘', 'wB': '♗', 'wQ': '♕', 'wK': '♔',
  'bP': '♟', 'bR': '♜', 'bN': '♞', 'bB': '♝', 'bQ': '♛', 'bK': '♚'
};

// Initialize board with starting positions
function initBoard() {
  board = [
    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
    ['bP','bP','bP','bP','bP','bP','bP','bP'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['wP','wP','wP','wP','wP','wP','wP','wP'],
    ['wR','wN','wB','wQ','wK','wB','wN','wR']
  ];
}

// Render the board in HTML
function renderBoard() {
  boardEl.innerHTML = '';
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const square = document.createElement('div');
      square.classList.add('square');
      square.classList.add((r + c) % 2 === 0 ? 'white' : 'black');
      square.dataset.row = r;
      square.dataset.col = c;
      square.innerHTML = pieces[board[r][c]] || '';
      square.addEventListener('click', handleClick);
      boardEl.appendChild(square);
    }
  }
}

// Handle click on square
function handleClick(e) {
  const row = parseInt(e.currentTarget.dataset.row);
  const col = parseInt(e.currentTarget.dataset.col);
  const piece = board[row][col];

  if (selected) {
    if (isValidMove(selected.row, selected.col, row, col)) {
      board[row][col] = board[selected.row][selected.col];
      board[selected.row][selected.col] = '';
      selected = null;
      turn = turn === 'w' ? 'b' : 'w';
      renderBoard();
      checkGameOver();
      return;
    }
    selected = null;
    renderBoard();
  } else if (piece && piece[0] === turn) {
    selected = {row, col};
    e.currentTarget.classList.add('highlight');
  }
}

// Simple move validation (basic, can be expanded for full chess rules)
function isValidMove(r1, c1, r2, c2) {
  const piece = board[r1][c1];
  const target = board[r2][c2];
  if (target && target[0] === piece[0]) return false;

  const dr = r2 - r1;
  const dc = c2 - c1;

  switch(piece[1]) {
    case 'P': // Pawn
      if (piece[0] === 'w') return (dc === 0 && dr === -1 && !target) || (dc !== 0 && dr === -1 && target && target[0]==='b');
      if (piece[0] === 'b') return (dc === 0 && dr === 1 && !target) || (dc !== 0 && dr === 1 && target && target[0]==='w');
      break;
    case 'R': return (dr===0 || dc===0) && clearPath(r1,c1,r2,c2);
    case 'B': return Math.abs(dr)===Math.abs(dc) && clearPath(r1,c1,r2,c2);
    case 'N': return (Math.abs(dr)===2 && Math.abs(dc)===1) || (Math.abs(dr)===1 && Math.abs(dc)===2);
    case 'Q': return (Math.abs(dr)===Math.abs(dc) || dr===0 || dc===0) && clearPath(r1,c1,r2,c2);
    case 'K': return Math.abs(dr)<=1 && Math.abs(dc)<=1;
  }
  return false;
}

// Check if path is clear for pieces (except knight)
function clearPath(r1,c1,r2,c2){
  const dr = Math.sign(r2-r1);
  const dc = Math.sign(c2-c1);
  let r=r1+dr, c=c1+dc;
  while(r!==r2 || c!==c2){
    if(board[r][c]) return false;
    r+=dr; c+=dc;
  }
  return true;
}

// Check basic game over
function checkGameOver() {
  let wK=false, bK=false;
  for (let row of board) for (let cell of row) {
    if (cell==='wK') wK=true;
    if (cell==='bK') bK=true;
  }
  if (!wK || !bK) {
    alert((!wK ? 'Black' : 'White') + ' wins!');
    resetBoard();
  }
}

// Restart
function resetBoard() {
  initBoard();
  turn='w';
  selected=null;
  renderBoard();
}

resetBoard();
</script>

</body>
</html>
