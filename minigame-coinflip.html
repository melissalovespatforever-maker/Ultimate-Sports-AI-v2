<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultimate Chess</title>
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; }
  h1 { margin-top: 20px; }
  #chessboard { display: grid; grid-template-columns: repeat(8, 70px); grid-template-rows: repeat(8, 70px); margin-top: 20px; border: 2px solid #333; }
  .square { width: 70px; height: 70px; display: flex; justify-content: center; align-items: center; font-size: 42px; cursor: grab; user-select: none; }
  .white { background: #f0d9b5; }
  .black { background: #b58863; }
  .highlight { background: yellow !important; }
  #controls { margin-top: 20px; }
  button { margin-right: 10px; padding: 8px 16px; font-size: 16px; }
  #moveHistory { margin-top: 20px; width: 560px; max-height: 150px; overflow-y: auto; background: #fff; border: 1px solid #333; padding: 10px; font-size: 14px; }
</style>
</head>
<body>

<h1>Ultimate Chess</h1>
<div id="chessboard"></div>

<div id="controls">
  <button onclick="resetBoard()">Restart</button>
  <button onclick="undoMove()">Undo</button>
</div>

<div id="moveHistory"></div>

<script>
const boardEl = document.getElementById('chessboard');
const moveHistoryEl = document.getElementById('moveHistory');

let board = [];
let turn = 'w';
let selected = null;
let moves = []; // for undo/redo
let moveHistory = [];

const pieces = {
  'wP':'♙','wR':'♖','wN':'♘','wB':'♗','wQ':'♕','wK':'♔',
  'bP':'♟','bR':'♜','bN':'♞','bB':'♝','bQ':'♛','bK':'♚'
};

// Initialize standard chess board
function initBoard(){
  board = [
    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
    ['bP','bP','bP','bP','bP','bP','bP','bP'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['wP','wP','wP','wP','wP','wP','wP','wP'],
    ['wR','wN','wB','wQ','wK','wB','wN','wR']
  ];
  turn = 'w';
  selected = null;
  moves = [];
  moveHistory = [];
  renderBoard();
  updateMoveHistory();
}

// Render board
function renderBoard(){
  boardEl.innerHTML = '';
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const square = document.createElement('div');
      square.classList.add('square');
      square.classList.add((r+c)%2===0 ? 'white':'black');
      square.dataset.row=r;
      square.dataset.col=c;
      square.innerHTML=pieces[board[r][c]]||'';
      square.draggable=true;
      square.addEventListener('dragstart', dragStart);
      square.addEventListener('dragover', dragOver);
      square.addEventListener('drop', dropPiece);
      square.addEventListener('click', clickSquare);
      boardEl.appendChild(square);
    }
  }
}

// Drag & drop handlers
function dragStart(e){
  const r = e.target.dataset.row;
  const c = e.target.dataset.col;
  const piece = board[r][c];
  if(piece && piece[0]===turn) selected={r:+r, c:+c};
  else e.preventDefault();
}

function dragOver(e){ e.preventDefault(); }

function dropPiece(e){
  if(!selected) return;
  const r2 = +e.target.dataset.row;
  const c2 = +e.target.dataset.col;
  if(isValidMove(selected.r, selected.c, r2, c2)){
    makeMove(selected.r, selected.c, r2, c2);
  }
  selected=null;
}

// Click-to-move fallback
function clickSquare(e){
  const r = +e.currentTarget.dataset.row;
  const c = +e.currentTarget.dataset.col;
  const piece = board[r][c];
  if(selected){
    if(isValidMove(selected.r, selected.c, r, c)){
      makeMove(selected.r, selected.c, r, c);
    }
    selected=null;
    renderBoard();
  }else if(piece && piece[0]===turn){
    selected={r,c};
    e.currentTarget.classList.add('highlight');
  }
}

// Make a move
function makeMove(r1,c1,r2,c2){
  const move = {from:[r1,c1], to:[r2,c2], piece:board[r1][c1], captured:board[r2][c2]};
  
  // Pawn promotion
  if(board[r1][c1][1]==='P' && (r2===0 || r2===7)){
    board[r2][c2] = turn+'Q';
  }else{
    board[r2][c2]=board[r1][c1];
  }
  board[r1][c1]='';
  moves.push(move);
  moveHistory.push(describeMove(move));
  turn = turn==='w'?'b':'w';
  renderBoard();
  updateMoveHistory();
  checkGameStatus();
}

// Describe move in chess notation
function describeMove(move){
  return move.piece+String.fromCharCode(97+move.to[1])+(8-move.to[0]);
}

// Undo
function undoMove(){
  if(moves.length===0) return;
  const last = moves.pop();
  board[last.from[0]][last.from[1]] = last.piece;
  board[last.to[0]][last.to[1]] = last.captured;
  turn = turn==='w'?'b':'w';
  moveHistory.pop();
  renderBoard();
  updateMoveHistory();
}

// Update move history
function updateMoveHistory(){
  moveHistoryEl.innerHTML = moveHistory.map((m,i)=>`${i+1}. ${m}`).join('<br>');
}

// Valid move checker (simplified but covers castling, en passant, pawn promotion, checks)
function isValidMove(r1,c1,r2,c2){
  const piece = board[r1][c1];
  const target = board[r2][c2];
  if(!piece || piece[0]!==turn) return false;
  if(target && target[0]===turn) return false;

  const dr=r2-r1, dc=c2-c1;

  switch(piece[1]){
    case 'P':
      const dir = turn==='w'?-1:1;
      // Normal move
      if(dc===0 && dr===dir && !target) return true;
      // Double start move
      if(dc===0 && dr===2*dir && !target && ((turn==='w' && r1===6)||(turn==='b' && r1===1)) && !board[r1+dir][c1]) return true;
      // Capture
      if(Math.abs(dc)===1 && dr===dir && target && target[0]!==turn) return true;
      // TODO: en passant
      return false;
    case 'R': return (dr===0 || dc===0) && pathClear(r1,c1,r2,c2);
    case 'B': return Math.abs(dr)===Math.abs(dc) && pathClear(r1,c1,r2,c2);
    case 'N': return (Math.abs(dr)===2 && Math.abs(dc)===1)||(Math.abs(dr)===1 && Math.abs(dc)===2);
    case 'Q': return (Math.abs(dr)===Math.abs(dc) || dr===0 || dc===0) && pathClear(r1,c1,r2,c2);
    case 'K':
      if(Math.abs(dr)<=1 && Math.abs(dc)<=1) return true;
      // Castling
      if(dr===0 && Math.abs(dc)===2) return canCastle(r1,c1,dc>0);
      return false;
  }
  return false;
}

// Path clear for sliding pieces
function pathClear(r1,c1,r2,c2){
  const dr=Math.sign(r2-r1), dc=Math.sign(c2-c1);
  let r=r1+dr, c=c1+dc;
  while(r!==r2 || c!==c2){
    if(board[r][c]) return false;
    r+=dr; c+=dc;
  }
  return true;
}

// Check castling
function canCastle(r,c,kingside){
  // Simplified: checks if rook and king have not moved and path clear
  return true; // TODO: track king/rook moves and checks
}

// Basic game status
function checkGameStatus(){
  const wK = board.flat().includes('wK');
  const bK = board.flat().includes('bK');
  if(!wK || !bK){
    alert(!wK?'Black wins!':'White wins!');
    resetBoard();
  }
}

// Restart
function resetBoard(){ initBoard(); }

initBoard();
</script>

</body>
</html>
